# Use @goField(forceResolver: true) to lazily handle recursive or expensive fields that shouldn't be
# resolved unless the caller asks for them
directive @goField(
    forceResolver: Boolean
    name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

# Add @authRequired to any field that requires a user to be logged in. NOTE: Any field tagged with
# @authRequired MUST return a union type that includes ErrNotAuthorized.
#
# If we need more control over auth in the future, this directive can be updated to take
# arguments that specify the level of access required.
directive @authRequired on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# Use @scrub on any input field that should be omitted from request logging (e.g. passwords or
# other sensitive data)
directive @scrub on INPUT_FIELD_DEFINITION

# Use @restrictEnvironment to choose which values of the ENV environment variable the annotated field/object
# should be usable in (case-insensitive). Example: @restrictEnvironment(allowed:["local", "development"]) would
# allow a field in "local" and "development" environments but not in "production"
directive @restrictEnvironment(allowed:[String!]!) on INPUT_FIELD_DEFINITION | INPUT_OBJECT | FIELD_DEFINITION | OBJECT

# All types that implement Node must have a unique GqlID set in their "id" field. For types with
# a "dbid" field, it's assumed that we can synthesize a unique ID from the type name and the dbid,
# so those types will automatically have an ID function generated for them (which gqlgen will find
# and bind to). Types without a dbid field, or types that need multiple inputs to create a unique ID
# that can be used to refetch the node in the future, must use the @goGqlId directive to explicitly
# state the fields that will be used to generate the ID. If a named field exists on the object and is
# a string-based type, that field will be used as part of the ID automatically. Otherwise, a manual
# getter method will need to be implemented to retrieve that component of the GqlID.
directive @goGqlId(fields:[String!]!) on OBJECT

# Injects a "Helper<TypeName>Data" struct embed into a generated type. Useful for adding backend-only
# helper data necessary to resolve queries, while keeping that data out of the schema and invisible
# to clients.
directive @goEmbedHelper on OBJECT

scalar Time
scalar Address
scalar DBID

interface Node {
    id: ID!
}

interface Error {
    message: String!
}

type GalleryUser implements Node {
    id: ID!
    dbid: DBID!
    username: String
    bio: String
    wallets: [Wallet]
    galleries: [Gallery] @goField(forceResolver: true)
    isAuthenticatedUser: Boolean
}

type Wallet implements Node @goGqlId(fields: ["address"]) {
    id: ID!
    address: Address
    # TODO: Do we paginate these currently?
    nfts: [Nft] @goField(forceResolver: true)
}

union GalleryUserOrWallet = GalleryUser | Wallet

union MediaSubtype =
    ImageMedia
    | VideoMedia
    | AudioMedia
    | TextMedia
    | HtmlMedia
    | JsonMedia
    | GltfMedia
    | UnknownMedia
    | InvalidMedia

type PreviewURLSet {
    raw: String
    small: String
    medium: String
    large: String
}

type ImageURLSet {
    raw: String
    small: String
    medium: String
    large: String
}

type VideoURLSet {
    raw: String
    small: String
    medium: String
    large: String
}

interface Media {
    # Various sizes of preview images for the media
    previewURLs: PreviewURLSet

    # The original source URL for the media (may be IPFS, etc)
    mediaURL: String

    # The type of media, as determined by the backend. May be redundant given the approach we're using here
    # (media subtypes implementing the Media interface)
    mediaType: String

    # All Media types will also have something like contentRenderURL or contentRenderURLs,
    # which are the URL(s) that should actually be used for rendering the media's content
}

type ImageMedia implements Media {
    previewURLs: PreviewURLSet
    mediaURL: String
    mediaType: String

    contentRenderURLs: ImageURLSet
}

type VideoMedia implements Media {
    previewURLs: PreviewURLSet
    mediaURL: String
    mediaType: String

    contentRenderURLs: VideoURLSet
}

type AudioMedia implements Media {
    previewURLs: PreviewURLSet
    mediaURL: String
    mediaType: String

    contentRenderURL: String
}

type TextMedia implements Media {
    previewURLs: PreviewURLSet
    mediaURL: String
    mediaType: String

    contentRenderURL: String
}

type HtmlMedia implements Media {
    previewURLs: PreviewURLSet
    mediaURL: String
    mediaType: String

    contentRenderURL: String
}

type JsonMedia implements Media {
    previewURLs: PreviewURLSet
    mediaURL: String
    mediaType: String

    contentRenderURL: String
}

type GltfMedia implements Media {
    previewURLs: PreviewURLSet
    mediaURL: String
    mediaType: String

    contentRenderURL: String
}

type UnknownMedia implements Media {
    previewURLs: PreviewURLSet
    mediaURL: String
    mediaType: String

    contentRenderURL: String
}

type InvalidMedia implements Media {
    previewURLs: PreviewURLSet
    mediaURL: String
    mediaType: String

    contentRenderURL: String
}

enum TokenType {
    ERC721
    ERC1155
    ERC20
}

enum Chain {
    Ethereum
    Arbitrum
    Polygon
    Optimism
}

type Nft implements Node {
    id: ID!
    dbid: DBID!
    creationTime: Time
    lastUpdated: Time
    collectorsNote: String
    media: MediaSubtype
    tokenType: TokenType
    chain: Chain
    name: String
    description: String
    tokenUri: String
    tokenId: String
    quantity: String # source is a hex string
    owner: GalleryUserOrWallet @goField(forceResolver: true)
    ownershipHistory: [OwnerAtBlock]
    tokenMetadata: String # source is map[string]interface{} on backend, not sure what best format is here
    contractAddress: Address
    externalUrl: String
    blockNumber: String # source is uint64

    # These are subject to change; unlike the other fields, they aren't present on the current persist.Token
    # struct and may ultimately end up elsewhere
    creatorAddress: Address
    openseaCollectionName: String

    # temporary field while we're dependent on opensea
    openseaId: Int
}

type OwnerAtBlock {
    # TODO: will need to store addresses to make this resolver work
    owner: GalleryUserOrWallet @goField(forceResolver: true)
    blockNumber: String # source is uint64
}

type CollectionNft implements Node @goEmbedHelper @goGqlId(fields:["nftId", "collectionId"]) {
    id: ID!
    nft: Nft
    collection: Collection
}

type CollectionLayout {
    columns: Int
    whitespace: [Int]
}

type Collection implements Node {
    id: ID!
    dbid: DBID!
    version: Int
    name: String
    collectorsNote: String
    gallery: Gallery @goField(forceResolver: true)
    layout: CollectionLayout
    hidden: Boolean
    nfts: [CollectionNft] @goField(forceResolver: true)
}

type Gallery implements Node {
    id: ID!
    dbid: DBID!
    owner: GalleryUser @goField(forceResolver: true)
    collections: [Collection] @goField(forceResolver: true)
}

type MembershipOwner {
    dbid: DBID!
    address: Address
    user: GalleryUser @goField(forceResolver: true)
    previewNfts: [String]
}

type MembershipTier implements Node {
    id: ID!
    dbid: DBID!
    name: String
    assetUrl: String
    tokenId: String
    owners: [MembershipOwner]
}

type CommunityOwner {
    address: Address
    username: String
}

type Community implements Node @goGqlId(fields: ["contractAddress"]) {
    id: ID!

    lastUpdated: Time

    contractAddress: Address
    creatorAddress: Address
    name: String
    description: String
    previewImage: String

    owners: [CommunityOwner]
}

# We have this extra type in case we need to stick authed data
# in here one day.
type ViewerGallery {
    gallery: Gallery
}

type Viewer {
    user: GalleryUser @goField(forceResolver: true)
    viewerGalleries: [ViewerGallery] @goField(forceResolver: true)
}
union UserByUsernameOrError = GalleryUser | ErrUserNotFound | ErrInvalidInput

union ViewerOrError = Viewer | ErrNotAuthorized

type ErrCollectionNotFound implements Error {
    message: String!
}

union NftByIdOrError = Nft | ErrNftNotFound

type ErrNftNotFound implements Error {
    message: String!
}

union CollectionByIdOrError = Collection | ErrCollectionNotFound

union CollectionNftByIdOrError = CollectionNft | ErrCollectionNotFound | ErrNftNotFound

union CommunityByAddressOrError = Community | ErrCommunityNotFound

type Query {
    node(id: ID!): Node
    viewer: ViewerOrError @authRequired
    userByUsername(username: String!): UserByUsernameOrError
    membershipTiers(forceRefresh: Boolean): [MembershipTier]
    collectionById(id: DBID!): CollectionByIdOrError
    nftById(id: DBID!): NftByIdOrError
    collectionNftById(nftId: DBID!, collectionId: DBID!): CollectionNftByIdOrError
    communityByAddress(contractAddress: Address!): CommunityByAddressOrError
    generalAllowlist: [Address!]
}

input CollectionLayoutInput {
    columns: Int!
    whitespace: [Int!]!
}

input CreateCollectionInput {
    galleryId: DBID!
    name: String!
    collectorsNote: String!
    nfts: [DBID!]!
    layout: CollectionLayoutInput!
}

union CreateCollectionPayloadOrError =
    CreateCollectionPayload
    | ErrNotAuthorized
    | ErrInvalidInput

type CreateCollectionPayload {
    collection: Collection
}

union DeleteCollectionPayloadOrError =
    DeleteCollectionPayload
    | ErrNotAuthorized
    | ErrInvalidInput
    | ErrCollectionNotFound

type DeleteCollectionPayload {
    gallery: Gallery
}

input UpdateCollectionInfoInput {
    collectionId: DBID!
    name: String!
    collectorsNote: String!
}

union UpdateCollectionInfoPayloadOrError =
    UpdateCollectionInfoPayload
    | ErrNotAuthorized
    | ErrInvalidInput

type UpdateCollectionInfoPayload {
    collection: Collection
}

input UpdateCollectionNftsInput {
    collectionId: DBID!
    nfts: [DBID!]!
    layout: CollectionLayoutInput!
}

union UpdateCollectionNftsPayloadOrError =
    UpdateCollectionNftsPayload
    | ErrNotAuthorized
    | ErrInvalidInput

type UpdateCollectionNftsPayload {
    collection: Collection
}

input UpdateCollectionHiddenInput {
    collectionId: DBID!
    hidden: Boolean!
}

union UpdateCollectionHiddenPayloadOrError =
    UpdateCollectionHiddenPayload
    | ErrNotAuthorized
    | ErrInvalidInput

type UpdateCollectionHiddenPayload {
    collection: Collection
}

input UpdateGalleryCollectionsInput {
    galleryId: DBID!
    collections: [DBID!]!
}

union UpdateGalleryCollectionsPayloadOrError =
    UpdateGalleryCollectionsPayload
    | ErrNotAuthorized
    | ErrInvalidInput

type UpdateGalleryCollectionsPayload {
    gallery: Gallery
}

input UpdateNftInfoInput {
    nftId: DBID!
    collectorsNote: String!

    # Optional (for now). Lets the backend know what collection the NFT was being edited in.
    # Currently used to generate feedbot URLs.
    collectionId: DBID
}

union UpdateNftInfoPayloadOrError =
    UpdateNftInfoPayload
    | ErrNotAuthorized
    | ErrInvalidInput

type UpdateNftInfoPayload {
    nft: Nft
}

union AddUserAddressPayloadOrError =
    AddUserAddressPayload
    | ErrAuthenticationFailed
    | ErrNotAuthorized
    | ErrInvalidInput

type AddUserAddressPayload {
    viewer: Viewer
}

union RemoveUserAddressesPayloadOrError =
    RemoveUserAddressesPayload
    | ErrNotAuthorized
    | ErrInvalidInput

type RemoveUserAddressesPayload {
    viewer: Viewer
}

input UpdateUserInfoInput {
    username: String!
    bio: String!
}

union UpdateUserInfoPayloadOrError =
    UpdateUserInfoPayload
    | ErrNotAuthorized
    | ErrInvalidInput
    | ErrUserAlreadyExists

type UpdateUserInfoPayload {
    viewer: Viewer
}

union RefreshOpenSeaNftsPayloadOrError =
    RefreshOpenSeaNftsPayload
    | ErrNotAuthorized
    | ErrOpenSeaRefreshFailed

type RefreshOpenSeaNftsPayload {
    viewer: Viewer
}

type AuthNonce {
    nonce: String
    userExists: Boolean
}

union GetAuthNoncePayloadOrError = AuthNonce | ErrDoesNotOwnRequiredNFT

type ErrAuthenticationFailed implements Error {
    message: String!
}

type ErrUserAlreadyExists implements Error {
    message: String!
}

type ErrUserNotFound implements Error {
    message: String!
}

type ErrCommunityNotFound implements Error {
    message: String!
}

union AuthorizationError =
    ErrNoCookie
    | ErrInvalidToken
    | ErrDoesNotOwnRequiredNFT

type ErrNotAuthorized implements Error {
    message: String!
    cause: AuthorizationError!
}

type ErrInvalidInput implements Error {
    message: String!
    parameters: [String!]!
    reasons: [String!]!
}

type ErrNoCookie implements Error {
    message: String!
}

type ErrInvalidToken implements Error {
    message: String!
}

type ErrDoesNotOwnRequiredNFT implements Error {
    message: String!
}

type ErrOpenSeaRefreshFailed implements Error {
    message: String!
}

input AuthMechanism {
    debugAuth: DebugAuth
    ethereumEoa: EthereumEoaAuth
    gnosisSafe: GnosisSafeAuth
}

# DebugAuth always succeeds and returns the supplied userId and addresses.
# Only available for local development.
input DebugAuth @restrictEnvironment(allowed: ["local"]){
    userId: DBID
    addresses: [Address!]!
}

input EthereumEoaAuth {
    address: Address!
    nonce: String!
    signature: String! @scrub
}

input GnosisSafeAuth {
    address: Address!
    nonce: String!
}

union LoginPayloadOrError =
    LoginPayload
    | ErrUserNotFound
    | ErrAuthenticationFailed
    | ErrDoesNotOwnRequiredNFT

type LoginPayload {
    # TODO: Remove userId in favor of viewer
    userId: DBID
    viewer: Viewer
}

type LogoutPayload {
    viewer: Viewer
}

union CreateUserPayloadOrError =
    CreateUserPayload
    | ErrUserAlreadyExists
    | ErrAuthenticationFailed
    | ErrDoesNotOwnRequiredNFT

type CreateUserPayload {
    userId: DBID
    galleryId: DBID
    # TODO: Remove userId and galleryId in favor of viewer
    viewer: Viewer
}

type Mutation {
    # User Mutations
    addUserAddress(address: Address!, authMechanism: AuthMechanism!): AddUserAddressPayloadOrError @authRequired
    removeUserAddresses(addresses: [Address!]!): RemoveUserAddressesPayloadOrError @authRequired
    updateUserInfo(input: UpdateUserInfoInput!): UpdateUserInfoPayloadOrError @authRequired

    # Gallery Mutations
    updateGalleryCollections(input: UpdateGalleryCollectionsInput!): UpdateGalleryCollectionsPayloadOrError @authRequired

    # Collection Mutations
    createCollection(input: CreateCollectionInput!): CreateCollectionPayloadOrError @authRequired
    deleteCollection(collectionId: DBID!): DeleteCollectionPayloadOrError @authRequired
    updateCollectionInfo(input: UpdateCollectionInfoInput!): UpdateCollectionInfoPayloadOrError @authRequired
    updateCollectionNfts(input: UpdateCollectionNftsInput!): UpdateCollectionNftsPayloadOrError @authRequired
    updateCollectionHidden(input: UpdateCollectionHiddenInput!): UpdateCollectionHiddenPayloadOrError @authRequired

    # Nft Mutations
    updateNftInfo(input: UpdateNftInfoInput!): UpdateNftInfoPayloadOrError @authRequired

    # Mirroring the existing input (comma-separated list of addresses) because we expect to drop this functionality soon
    refreshOpenSeaNfts(addresses: String): RefreshOpenSeaNftsPayloadOrError @authRequired

    getAuthNonce(address: Address!): GetAuthNoncePayloadOrError

    createUser(authMechanism: AuthMechanism!): CreateUserPayloadOrError
    login(authMechanism: AuthMechanism!): LoginPayloadOrError
    logout: LogoutPayload
}