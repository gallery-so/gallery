# Use @goField(forceResolver: true) to lazily handle recursive or expensive fields that shouldn't be
# resolved unless the caller asks for them
directive @goField(
  forceResolver: Boolean
  name: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION

# Add @authRequired to any field that requires a user to be logged in. NOTE: Any field tagged with
# @authRequired MUST return a union type that includes ErrNotAuthorized.
#
# If we need more control over auth in the future, this directive can be updated to take
# arguments that specify the level of access required.
directive @authRequired on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

# Use @scrub on any input field that should be omitted from request logging (e.g. passwords or
# other sensitive data)
directive @scrub on INPUT_FIELD_DEFINITION

# All types that implement Node must have a unique GqlID set in their "id" field. For types with
# a "dbid" field, it's assumed that we can synthesize a unique ID from the type name and the dbid,
# so those types will automatically have an ID function generated for them (which gqlgen will find
# and bind to). Types without a dbid field, or types that need multiple inputs to create a unique ID
# that can be used to refetch the node in the future, must use the @goGqlId directive to explicitly
# state the fields that will be used to generate the ID. If a named field exists on the object and is
# a string-based type, that field will be used as part of the ID automatically. Otherwise, a manual
# getter method will need to be implemented to retrieve that component of the GqlID.
directive @goGqlId(fields: [String!]!) on OBJECT

# Injects a "Helper<TypeName>Data" struct embed into a generated type. Useful for adding backend-only
# helper data necessary to resolve queries, while keeping that data out of the schema and invisible
# to clients.
directive @goEmbedHelper on OBJECT

scalar Time
scalar Address
scalar DBID

interface Node {
  id: ID!
}

interface Error {
  message: String!
}

type GalleryUser implements Node {
  id: ID!
  dbid: DBID!
  username: String
  bio: String
  wallets: [Wallet]
  galleries: [Gallery] @goField(forceResolver: true)
  isAuthenticatedUser: Boolean
}

type Wallet implements Node @goGqlId(fields: ["address"]) {
  id: ID!
  address: Address
  # TODO: Do we paginate these currently?
  nfts: [Nft] @goField(forceResolver: true)
}

union GalleryUserOrWallet = GalleryUser | Wallet

union MediaSubtype =
    ImageMedia
  | VideoMedia
  | AudioMedia
  | TextMedia
  | HtmlMedia
  | JsonMedia
  | UnknownMedia
  | InvalidMedia

type PreviewURLSet {
  raw: String
  small: String
  medium: String
  large: String
}

type ImageURLSet {
  raw: String
  small: String
  medium: String
  large: String
}

type VideoURLSet {
  raw: String
  small: String
  medium: String
  large: String
}

interface Media {
  # Various sizes of preview images for the media
  previewURLs: PreviewURLSet

  # The original source URL for the media (may be IPFS, etc)
  mediaURL: String

  # The type of media, as determined by the backend. May be redundant given the approach we're using here
  # (media subtypes implementing the Media interface)
  mediaType: String

  # All Media types will also have something like contentRenderURL or contentRenderURLs,
  # which are the URL(s) that should actually be used for rendering the media's content
}

type ImageMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURLs: ImageURLSet
}

type VideoMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURLs: VideoURLSet
}

type AudioMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
}

type TextMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
}

type HtmlMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
}

type JsonMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
}

type UnknownMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
}

type InvalidMedia implements Media {
  previewURLs: PreviewURLSet
  mediaURL: String
  mediaType: String

  contentRenderURL: String
}

enum TokenType {
  ERC721
  ERC1155
  ERC20
}

enum Chain {
  Ethereum
  Arbitrum
  Polygon
  Optimism
}

type Nft implements Node {
  id: ID!
  dbid: DBID!
  creationTime: Time
  lastUpdated: Time
  collectorsNote: String
  media: MediaSubtype
  tokenType: TokenType
  chain: Chain
  name: String
  description: String
  tokenUri: String
  tokenId: String
  quantity: String # source is a hex string
  owner: GalleryUserOrWallet @goField(forceResolver: true)
  ownershipHistory: [OwnerAtBlock]
  tokenMetadata: String # source is map[string]interface{} on backend, not sure what best format is here
  contractAddress: Address
  externalUrl: String
  blockNumber: String # source is uint64
}

type OwnerAtBlock {
  # TODO: will need to store addresses to make this resolver work
  owner: GalleryUserOrWallet @goField(forceResolver: true)
  blockNumber: String # source is uint64
}

type GalleryNft implements Node @goEmbedHelper @goGqlId(fields: ["nftId", "collectionId"]) {
  id: ID!
  nft: Nft
  # next: GalleryNft
  # prev: GalleryNft
  collection: GalleryCollection
}

type GalleryCollectionLayout {
  columns: Int
  whitespace: [Int]
}

type GalleryCollection implements Node {
  id: ID!
  dbid: DBID!
  version: Int
  name: String
  collectorsNote: String
  gallery: Gallery @goField(forceResolver: true)
  layout: GalleryCollectionLayout
  hidden: Boolean
  nfts: [GalleryNft] @goField(forceResolver: true)
}

type Gallery implements Node {
  id: ID!
  dbid: DBID!
  owner: GalleryUser @goField(forceResolver: true)
  collections: [GalleryCollection] @goField(forceResolver: true)
}

type MembershipOwner implements Node {
  id: ID!
  dbid: DBID!
  address: Address
  user: GalleryUser @goField(forceResolver: true)
  previewNfts: [String]
}

type MembershipTier implements Node {
  id: ID!
  dbid: DBID!
  name: String
  assetUrl: String
  tokenId: String
  owners: [MembershipOwner]
}

# We have this extra type in case we need to stick authed data
# in here one day.
type ViewerGallery {
  gallery: Gallery
}

type Viewer {
  user: GalleryUser @goField(forceResolver: true)
  viewerGalleries: [ViewerGallery] @goField(forceResolver: true)
}
union UserByUsernameOrError = GalleryUser | ErrUserNotFound | ErrInvalidInput

union ViewerOrError = Viewer | ErrNotAuthorized

type ErrCollectionNotFound implements Error {
  message: String!
}

union CollectionByIdOrError = ErrCollectionNotFound | GalleryCollection

type Query {
  viewer: ViewerOrError @authRequired
  userByUsername(username: String!): UserByUsernameOrError
  membershipTiers(forceRefresh: Boolean): [MembershipTier]
  collectionById(id: DBID!): CollectionByIdOrError
}

input GalleryCollectionLayoutInput {
  columns: Int!
  whitespace: [Int!]!
}

input CreateCollectionInput {
  galleryId: DBID!
  name: String!
  collectorsNote: String!
  nfts: [DBID!]!
  layout: GalleryCollectionLayoutInput!
}

union CreateCollectionPayloadOrError = CreateCollectionPayload | ErrNotAuthorized | ErrInvalidInput

type CreateCollectionPayload {
  collection: GalleryCollection
}

union DeleteCollectionPayloadOrError =
    DeleteCollectionPayload
  | ErrNotAuthorized
  | ErrInvalidInput
  | ErrCollectionNotFound

type DeleteCollectionPayload {
  gallery: Gallery
}

input UpdateCollectionInfoInput {
  collectionId: DBID!
  name: String!
  collectorsNote: String!
}

union UpdateCollectionInfoPayloadOrError =
    UpdateCollectionInfoPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type UpdateCollectionInfoPayload {
  collection: GalleryCollection
}

input UpdateCollectionNftsInput {
  collectionId: DBID!
  nfts: [DBID!]!
  layout: GalleryCollectionLayoutInput!
}

union UpdateCollectionNftsPayloadOrError =
    UpdateCollectionNftsPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type UpdateCollectionNftsPayload {
  collection: GalleryCollection
}

input UpdateGalleryCollectionsInput {
  galleryId: DBID!
  collections: [DBID!]!
}

union UpdateGalleryCollectionsPayloadOrError =
    UpdateGalleryCollectionsPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type UpdateGalleryCollectionsPayload {
  gallery: Gallery
}

union AddUserAddressPayloadOrError =
    AddUserAddressPayload
  | ErrAuthenticationFailed
  | ErrNotAuthorized
  | ErrInvalidInput

type AddUserAddressPayload {
  viewer: Viewer
}

union RemoveUserAddressesPayloadOrError =
    RemoveUserAddressesPayload
  | ErrNotAuthorized
  | ErrInvalidInput

type RemoveUserAddressesPayload {
  viewer: Viewer
}

input UpdateUserInfoInput {
  username: String!
  bio: String!
}

union UpdateUserInfoPayloadOrError = UpdateUserInfoPayload | ErrNotAuthorized | ErrInvalidInput

type UpdateUserInfoPayload {
  viewer: Viewer
}

union RefreshOpenSeaNftsPayloadOrError = RefreshOpenSeaNftsPayload | ErrNotAuthorized

type RefreshOpenSeaNftsPayload {
  viewer: Viewer
}

type AuthNonce {
  nonce: String
  userExists: Boolean
}

union GetAuthNoncePayloadOrError = AuthNonce | ErrDoesNotOwnRequiredNFT

type ErrAuthenticationFailed implements Error {
  message: String!
}

type ErrUserAlreadyExists implements Error {
  message: String!
}

type ErrUserNotFound implements Error {
  message: String!
}

union AuthorizationError = ErrNoCookie | ErrInvalidToken | ErrDoesNotOwnRequiredNFT

type ErrNotAuthorized implements Error {
  message: String!
  cause: AuthorizationError!
}

type ErrInvalidInput implements Error {
  message: String!
  parameters: [String!]!
  reasons: [String!]!
}

type ErrNoCookie implements Error {
  message: String!
}

type ErrInvalidToken implements Error {
  message: String!
}

type ErrDoesNotOwnRequiredNFT implements Error {
  message: String!
}

input AuthMechanism {
  ethereumEoa: EthereumEoaAuth
  gnosisSafe: GnosisSafeAuth
}

input EthereumEoaAuth {
  address: Address!
  nonce: String!
  signature: String! @scrub
}

input GnosisSafeAuth {
  address: Address!
  nonce: String!
}

union LoginPayloadOrError =
    LoginPayload
  | ErrUserNotFound
  | ErrAuthenticationFailed
  | ErrDoesNotOwnRequiredNFT

type LoginPayload {
  userId: DBID
}

union CreateUserPayloadOrError =
    CreateUserPayload
  | ErrUserAlreadyExists
  | ErrAuthenticationFailed
  | ErrDoesNotOwnRequiredNFT

type CreateUserPayload {
  userId: DBID
  galleryId: DBID
}

type Mutation {
  # Collection Mutations
  createCollection(input: CreateCollectionInput!): CreateCollectionPayloadOrError @authRequired
  deleteCollection(collectionId: DBID!): DeleteCollectionPayloadOrError @authRequired
  updateCollectionInfo(input: UpdateCollectionInfoInput!): UpdateCollectionInfoPayloadOrError
    @authRequired
  updateCollectionNfts(input: UpdateCollectionNftsInput!): UpdateCollectionNftsPayloadOrError
    @authRequired

  # Gallery Mutations
  updateGalleryCollections(
    input: UpdateGalleryCollectionsInput!
  ): UpdateGalleryCollectionsPayloadOrError @authRequired

  # User Mutations
  addUserAddress(address: Address!, authMechanism: AuthMechanism!): AddUserAddressPayloadOrError
    @authRequired
  removeUserAddresses(addresses: [Address!]!): RemoveUserAddressesPayloadOrError @authRequired
  updateUserInfo(input: UpdateUserInfoInput!): UpdateUserInfoPayloadOrError @authRequired

  # Mirroring the existing input (comma-separated list of addresses) because we expect to drop this functionality soon
  refreshOpenSeaNfts(addresses: String!): RefreshOpenSeaNftsPayloadOrError @authRequired

  getAuthNonce(address: Address!): GetAuthNoncePayloadOrError

  createUser(authMechanism: AuthMechanism!): CreateUserPayloadOrError
  login(authMechanism: AuthMechanism!): LoginPayloadOrError
}
