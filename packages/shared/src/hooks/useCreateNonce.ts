import { useCallback } from 'react';
import { graphql } from 'relay-runtime';

import { Chain, useCreateNonceMutation } from '~/generated/useCreateNonceMutation.graphql';

import { usePromisifiedMutation } from '../relay/usePromisifiedMutation';
import { Web3Error } from '../utils/Error';

/**
 * Retrieve a nonce for the client to sign given a wallet address.
 * Endpoint will also notify whether the user exists or not, so the
 * client can login or signup accordingly
 */
type NonceResponse = {
  nonce: string;
  user_exists: boolean;
};

export default function useCreateNonce() {
  const [createNonce] = usePromisifiedMutation<useCreateNonceMutation>(
    graphql`
      mutation useCreateNonceMutation($chainAddress: ChainAddressInput!) {
        getAuthNonce(chainAddress: $chainAddress) {
          __typename

          ... on AuthNonce {
            userExists @required(action: THROW)
            nonce @required(action: THROW)
          }

          ... on ErrDoesNotOwnRequiredToken {
            message
          }
        }
      }
    `
  );

  return useCallback(
    async (address: string, chain: Chain): Promise<NonceResponse> => {
      // Kick off the mutation network request
      //
      // This call can throw an error. This error is the equivalent
      // of either a 500, or a network error (the user didn't have connection)
      //
      // If this throws, we'll just let the UI handle that appropriately
      // with it's try catch
      const { getAuthNonce } = await createNonce({
        variables: { chainAddress: { address, chain } },
      });

      // If the server didn't give us a payload for the mutation we just committed,
      // we'll throw an error with a somewhat helpful message. This usually means
      // the server panicked at some point in the stack and was unable to commit
      // the mutation.
      if (!getAuthNonce) {
        throw new Error('getAuthNonce failed to execute. response data missing');
      }

      // The types generated by Relay let us do some great TypeScript
      // union checks here. Inside of this if, we'll have narrowed the
      // the type down to be the ErrDoesNotOwnRequiredToken type so we
      // can access the relevant fields.
      if (getAuthNonce?.__typename === 'ErrDoesNotOwnRequiredToken') {
        const errorWithCode: Web3Error = {
          name: getAuthNonce.__typename,
          code: 'GALLERY_SERVER_ERROR',
          message: getAuthNonce.message,
        };

        throw errorWithCode;
      }

      // Same thing here. If the response's typename is AuthNonce
      // that means the type has a nonce, and userExists field
      if (getAuthNonce?.__typename === 'AuthNonce') {
        return { nonce: getAuthNonce.nonce, user_exists: getAuthNonce.userExists };
      }

      // The server added some new type to the union and we don't know what to do.
      throw new Error(
        `Unexpected type returned from createNonceMutation: ${getAuthNonce.__typename}`
      );
    },
    [createNonce]
  );
}
